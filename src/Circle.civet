{ createMemo, createSignal, For, Show } from 'solid-js'

colorMap :=
  . 'yellow'
  . 'orange'
  . 'red'
  . 'purple'
  . 'green'
  . 'blue'
  . 'indigo'
  . 'violet'

export function Arrow(props: { id: string, fill: string })
  <marker {props.id} markerWidth=5 markerHeight=5 refX=2.5 refY=1.5 orient="auto-start-reverse" markerUnits="strokeWidth">
    <path d="M0,0 L0,3 L4,1.5 z" {props.fill}>

/**
props.neighbor(i, n, a) should return an index j to draw arrow to,
or undefined to draw no arrow.
*/
export function Circle(props: {
  neighbor: (i: number, n: number, a: number) => number?
  noA?: boolean
  symmetric?: boolean
})
  [n, setN] := createSignal 10
  [a, setA] := createSignal 2

  radius := 40
  r := => 6 - n() / 8

  dots := createMemo =>
    nn := n()
    for i of [0..<nn]
      angle := (2 * Math.PI * i) / nn
      i: i
      x: radius * Math.cos angle
      y: radius * Math.sin angle

  connections := createMemo =>
    aa := a()
    nn := n()
    dd := dots()
    for source, i of dd
      targetIndex := props.neighbor i, nn, aa
      continue with undefined unless targetIndex?
      target .= dd[targetIndex]
      if targetIndex is i
        target =
          i: i
          x: (1 + 20 / radius) * source.x
          y: (1 + 20 / radius) * source.y
      dx := target.x - source.x
      dy := target.y - source.y
      dist := Math.sqrt dx*dx + dy*dy
      shorten := 5
      shortenedFrom := if dist <= shorten then target else
        x: source.x + dx * shorten / dist
        y: source.y + dy * shorten / dist
      shortenedTo := if dist <= shorten then target else
        x: target.x - dx * shorten / dist
        y: target.y - dy * shorten / dist
      { source, target, from: shortenedFrom, to: shortenedTo }

  colors := createMemo =>
    map := new Map<number, number>
    dd := dots()
    cc := connections()
    color .= 0
    for i of [0..<dd#]
      unless map.has i
        map.set i, color
        j .= cc[i]?.target.i
        while j? and not map.has j
          map.set j, color
          j = cc[j]?.target.i
        color++
      map.get(i)!

  <.circle>
    <.controls>
      <label>
        <i>n</i>:
        <input type="range" min=1 max=25 value=n() onInput=
          (e) => setN Number e.target.value
        >
        <input type="number" min=1 max=25 value=n() onInput=
          (e) => setN Number e.target.value
        >
      <Show when={not props.noA}>
        <label>
          <i>a</i>:
          <input type="range" min=1 max=n() value=a() onInput=
            (e) => setA Number e.target.value
          >
          <input type="number" min=1 max=n() value=a() onInput=
            (e) => setA Number e.target.value
          >
    <svg viewBox="-50 -50 100 100">
      <radialGradient #circleGradient cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="purple">
        <stop offset="100%" stop-color="#4B0082">
      <Arrow id="arrow-white" fill="white">
      <For each=connections()>
        (conn, i) =>
          color := createMemo => colorMap[colors()[i()] %% colorMap#]
          <Show when=conn>(count) =>
            <Arrow id=`arrow-${i()}` fill=color()>
            <linearGradient id=`grad-${i()}` x1={conn!.from.x} y1={conn!.from.y} x2={conn!.to.x} y2={conn!.to.y} gradientUnits="userSpaceOnUse">
              <stop offset="0%" stop-color="white">
              <stop offset="100%" stop-color=color()>
            <line x1=conn!.from.x y1=conn!.from.y x2=conn!.to.x y2=conn!.to.y
             stroke=`url(#grad-${i()})` stroke-width=2
             marker-end=`url(#arrow-${i()})`
             marker-start={if props.symmetric and conn!.source.i is not conn!.target.i then "url(#arrow-white)"}
            >
      <For each=dots()>
        (dot) =>
          <circle cx=dot.x cy=dot.y r=r()>
          <text x=dot.x y=dot.y font-size=`${1.2 * r()}px`>
            {dot.i}
