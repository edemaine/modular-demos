{ createMemo, createSignal, For, Show } from 'solid-js'

colorMap :=
  . 'yellow'
  . 'orange'
  . 'red'
  . 'purple'
  . 'green'
  . 'blue'
  . 'indigo'
  . 'violet'

export function Arrow(props: { id: string, fill: string })
  <marker {props.id} markerWidth=5 markerHeight=5 refX=2.5 refY=1.5 orient="auto-start-reverse" markerUnits="strokeWidth">
    <path d="M0,0 L0,3 L4,1.5 z" {props.fill}>

/**
props.neighbor(i, n, a) should return an index j to draw arrow to,
or undefined to draw no arrow.
*/
export function Circle(props: {
  neighbor: (i: number, n: number, a: number) => number?
  noA?: boolean
  symmetric?: boolean
})
  [n, setN] := createSignal 10
  [a, setA] := createSignal 2
  [curves, setCurves] := createSignal true

  radius := 40
  r := => 6 - n() / 8

  dots := createMemo =>
    nn := n()
    for i of [0..<nn]
      angle := (2 * Math.PI * i) / nn
      i: i
      x: radius * Math.cos angle
      y: radius * Math.sin angle

  connections := createMemo =>
    aa := a()
    nn := n()
    dd := dots()
    nodeR := r()
    for source, i of dd
      targetIndex := props.neighbor i, nn, aa
      continue with undefined unless targetIndex?
      target .= dd[targetIndex]

      let d: string // <path d=...>
      if targetIndex is i // self-loop
        //target =
        //  i: i
        //  x: (1 + 20 / radius) * source.x
        //  y: (1 + 20 / radius) * source.y
        perpX .= -source.y
        perpY .= source.x
        perpLen := Math.sqrt(perpX*perpX + perpY*perpY) or 0.0001
        perpX /= perpLen
        perpY /= perpLen
        outX := source.x / radius
        outY := source.y / radius
        scale := nodeR / Math.sqrt 2
        leftX := (outX - perpX) * scale
        leftY := (outY - perpY) * scale
        rightX := (outX + perpX) * scale
        rightY := (outY + perpY) * scale
        rad := nodeR * 0.8
        d = `M ${source.x + leftX} ${source.y + leftY} A ${rad} ${rad} 0 1 1 ${source.x + rightX} ${source.y + rightY}`

      else
        // Straight line drawing, offset to not overlap nodes
        dx := target.x - source.x
        dy := target.y - source.y
        dist := Math.sqrt(dx*dx + dy*dy) or 0.0001
        shorten := nodeR
        if dist <= 2*shorten
          d = `M ${source.x} ${source.y} L ${target.x} ${target.y}`
        else
          offSource :=
            x: source.x + dx * shorten / dist
            y: source.y + dy * shorten / dist
          offTarget :=
            x: target.x - dx * shorten / dist
            y: target.y - dy * shorten / dist
          d = `M ${offSource.x} ${offSource.y} L ${offTarget.x} ${offTarget.y}`

        // Attempt to draw connection like a Poincaré disk geodesic:
        // circle orthogonal to unit boundary.
        for [1..1] // allow break to fallback to default d
          break unless curves()
          // Solve for center cUnit of circle (in unit disk coords) that
          // satisfies C·z = (|z|^2 + 1)/2 for z = fUnit and tUnit.
          fUnit := { x: source.x / radius, y: source.y / radius }
          tUnit := { x: target.x / radius, y: target.y / radius }
          x1 := fUnit.x
          y1 := fUnit.y
          x2 := tUnit.x
          y2 := tUnit.y
          b1 := (x1*x1 + y1*y1 + 1) / 2
          b2 := (x2*x2 + y2*y2 + 1) / 2
          D := x1*y2 - x2*y1
          // degenerate (nearly collinear with origin) -> draw straight line
          break if Math.abs(D) < 1e-9
          cxUnit := (b1*y2 - b2*y1) / D
          cyUnit := (x1*b2 - x2*b1) / D
          rUnitSq := cxUnit*cxUnit + cyUnit*cyUnit - 1
          rUnit := Math.sqrt(Math.max(rUnitSq, 0))
          C := { x: cxUnit * radius, y: cyUnit * radius }
          R := rUnit * radius

          // compute arc flags and shorten along the arc by node radius
          v1x := source.x - C.x
          v1y := source.y - C.y
          v2x := target.x - C.x
          v2y := target.y - C.y
          dot := v1x*v2x + v1y*v2y
          cross := v1x*v2y - v1y*v2x
          // sweep direction (1 = CCW, 0 = CW)
          sweep := cross > 0 ? 1 : 0

          // shorten along arc by computing circle-circle intersections
          // (no trig): intersect circle(C,R) with circle(source,nodeR) and
          // circle(C,R) with circle(target,nodeR) to get arc endpoints.
          break if R <= 1e-6 or nodeR >= 2 * R
          // intersection near source
          df := Math.sqrt (source.x - C.x)**2 + (source.y - C.y)**2
          a := (R*R - nodeR*nodeR + df*df) / (2 * df)
          h2 := R*R - a*a
          break if h2 < 0
          p2x := C.x + a * (source.x - C.x) / df
          p2y := C.y + a * (source.y - C.y) / df
          h := Math.sqrt(h2)
          rx := -(source.y - C.y)
          ry := (source.x - C.x)
          i1x := p2x + (h * rx) / df
          i1y := p2y + (h * ry) / df
          i2x := p2x - (h * rx) / df
          i2y := p2y - (h * ry) / df
          // choose intersection that moves source toward target
          crossFT := (source.x - C.x) * (target.y - C.y) - (source.y - C.y) * (target.x - C.x)
          crossI1 := (source.x - C.x) * (i1y - C.y) - (source.y - C.y) * (i1x - C.x)
          sX := if crossI1 * crossFT > 0 then i1x else i2x
          sY := if crossI1 * crossFT > 0 then i1y else i2y

          // intersection near target
          dt := Math.sqrt((target.x - C.x)*(target.x - C.x) + (target.y - C.y)*(target.y - C.y))
          at := (R*R - nodeR*nodeR + dt*dt) / (2 * dt)
          h2t := R*R - at*at
          break if h2t < 0
          p2tx := C.x + at * (target.x - C.x) / dt
          p2ty := C.y + at * (target.y - C.y) / dt
          ht := Math.sqrt(h2t)
          rxt := -(target.y - C.y)
          ryt := (target.x - C.x)
          j1x := p2tx + (ht * rxt) / dt
          j1y := p2ty + (ht * ryt) / dt
          j2x := p2tx - (ht * rxt) / dt
          j2y := p2ty - (ht * ryt) / dt
          crossJ1 := (j1x - C.x) * (target.y - C.y) - (j1y - C.y) * (target.x - C.x)
          eX := if crossJ1 * crossFT > 0 then j1x else j2x
          eY := if crossJ1 * crossFT > 0 then j1y else j2y

          d = `M ${sX} ${sY} A ${R} ${R} 0 0 ${sweep} ${eX} ${eY}`

      {source, target, d}

  colors := createMemo =>
    map := new Map<number, number>
    dd := dots()
    cc := connections()
    color .= 0
    for i of [0..<dd#]
      unless map.has i
        map.set i, color
        j .= cc[i]?.target.i
        while j? and not map.has j
          map.set j, color
          j = cc[j]?.target.i
        color++
      map.get(i)!

  <.circle>
    <.controls>
      <label>
        <i>n</i>:
        <input type="range" min=1 max=25 value=n() onInput=
          (e) => setN Number e.currentTarget.value
        >
        <input type="number" min=1 max=25 value=n() onInput=
          (e) => setN Number e.currentTarget.value
        >
      <Show when={not props.noA}>
        <label>
          <i>a</i>:
          <input type="range" min=1 max=n() value=a() onInput=
            (e) => setA Number e.currentTarget.value
          >
          <input type="number" min=1 max=n() value=a() onInput=
            (e) => setA Number e.currentTarget.value
          >
      <label>
        <input type="checkbox" checked=curves() onInput=
          (e) => setCurves e.currentTarget.checked
        >
        &nbsp;Curves
    <svg viewBox="-50 -50 100 100">
      <radialGradient #circleGradient cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="purple">
        <stop offset="100%" stop-color="#4B0082">
      <Arrow id="arrow-white" fill="white">
      <For each=connections()>
        (conn, i) =>
          color := createMemo => colorMap[colors()[i()] %% colorMap#]
          <Show when=conn>(count) =>
            <Arrow id=`arrow-${i()}` fill=color()>
            <linearGradient id=`grad-${i()}` x1={conn!.source.x} y1={conn!.source.y} x2={conn!.target.x} y2={conn!.target.y} gradientUnits="userSpaceOnUse">
              <stop offset="0%" stop-color="white">
              <stop offset="100%" stop-color=color()>
            <path d=conn!.d
             stroke=`url(#grad-${i()})` stroke-width=2 fill="none"
             marker-end=`url(#arrow-${i()})`
             marker-start={if props.symmetric and conn!.source.i is not conn!.target.i then "url(#arrow-white)"}
            >
      <For each=dots()>
        (dot) =>
          <circle cx=dot.x cy=dot.y r=r()>
          <text x=dot.x y=dot.y font-size=`${1.2 * r()}px`>
            {dot.i}
